# 关键词工具批处理改造技术实现方案

## 代码架构分析

### 当前核心代码结构
```
popup.js (741行)
├── KeywordProcessor 类
│   ├── constructor() - 初始化
│   ├── init() - 事件监听和配置加载
│   ├── setupEventListeners() - 事件绑定
│   ├── loadApiConfig() - API配置加载
│   ├── processFile() - 单文件处理核心逻辑
│   ├── translateKeywords() - 关键词翻译（当前20个一批）
│   ├── calculateKdroi() - ROI计算
│   ├── generateLinks() - 链接生成
│   ├── exportToExcel() - Excel导出
│   └── updateProgress() - 进度更新
```

## 技术实现方案

### 1. 多文件选择功能实现

#### HTML修改 (popup.html)
```html
<!-- 当前单文件选择 -->
<input type="file" id="fileInput" accept=".xlsx">

<!-- 修改为多文件选择 -->
<input type="file" id="fileInput" accept=".xlsx" multiple>

<!-- 添加文件列表显示区域 -->
<div id="fileList" class="file-list">
  <h3>待处理文件</h3>
  <div id="selectedFiles"></div>
</div>

<!-- 添加批量处理按钮 -->
<button id="batchProcessBtn" class="btn btn-primary" disabled>开始批量处理</button>
```

#### CSS样式添加
```css
.file-list {
  margin: 15px 0;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 5px;
  background: #f9f9f9;
}

.file-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 5px 0;
  border-bottom: 1px solid #eee;
}

.file-status {
  font-size: 12px;
  padding: 2px 6px;
  border-radius: 3px;
}

.status-pending { background: #fff3cd; color: #856404; }
.status-processing { background: #d1ecf1; color: #0c5460; }
.status-completed { background: #d4edda; color: #155724; }
.status-failed { background: #f8d7da; color: #721c24; }
```

#### JavaScript逻辑修改
```javascript
// 修改 setupEventListeners() 方法
setupEventListeners() {
    const fileInput = document.getElementById('fileInput');
    const uploadArea = document.getElementById('uploadArea');
    const batchProcessBtn = document.getElementById('batchProcessBtn');

    // 文件选择事件
    fileInput.addEventListener('change', (e) => {
        this.handleFileSelection(e.target.files);
    });

    // 批量处理按钮
    batchProcessBtn.addEventListener('click', () => {
        this.startBatchProcessing();
    });

    // 拖拽上传支持多文件
    uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        this.handleFileSelection(e.dataTransfer.files);
    });
}

// 新增文件选择处理方法
handleFileSelection(files) {
    this.selectedFiles = Array.from(files).filter(file =>
        file.name.toLowerCase().endsWith('.xlsx')
    );

    this.updateFileList();
    this.updateBatchProcessButton();
}

// 更新文件列表显示
updateFileList() {
    const container = document.getElementById('selectedFiles');
    container.innerHTML = '';

    this.selectedFiles.forEach((file, index) => {
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        fileItem.innerHTML = `
            <span>${file.name} (${this.formatFileSize(file.size)})</span>
            <span class="file-status status-pending" id="file-${index}-status">等待处理</span>
        `;
        container.appendChild(fileItem);
    });
}

// 更新批量处理按钮状态
updateBatchProcessButton() {
    const batchProcessBtn = document.getElementById('batchProcessBtn');
    batchProcessBtn.disabled = this.selectedFiles.length === 0 || this.isProcessing;
    batchProcessBtn.textContent = this.selectedFiles.length > 0
        ? `处理 ${this.selectedFiles.length} 个文件`
        : '开始批量处理';
}
```

### 2. API批处理优化实现

#### 修改 translateKeywords 方法
```javascript
// 当前方法 (每批20个)
async translateKeywords(keywords) {
    const batchSize = 20;
    const results = [];

    for (let i = 0; i < keywords.length; i += batchSize) {
        const batch = keywords.slice(i, i + batchSize);
        const translations = await this.translateBatch(batch);
        results.push(...translations);
    }

    return results;
}

// 优化后的方法 (每批1000个)
async translateKeywords(keywords) {
    const batchSize = 1000;
    const results = [];

    for (let i = 0; i < keywords.length; i += batchSize) {
        const batch = keywords.slice(i, i + batchSize);
        const translations = await this.translateBatch(batch);
        results.push(...translations);

        // 更新进度显示
        this.updateProgress({
            stage: 'translating',
            current: i + batch.length,
            total: keywords.length,
            fileName: this.currentFile.name
        });
    }

    return results;
}

// 优化批处理翻译方法
async translateBatch(keywords) {
    const prompt = `请将以下关键词翻译成中文，每行一个：
${keywords.map(k => k.Keyword).join('\n')}

请按照以下格式返回：
关键词1: 中文翻译1
关键词2: 中文翻译2
...`;

    try {
        const response = await fetch(`${this.apiEndpoint}/chat/completions`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${this.apiKey}`
            },
            body: JSON.stringify({
                model: 'deepseek-chat',
                messages: [
                    { role: 'user', content: prompt }
                ],
                temperature: 0.3
            })
        });

        if (!response.ok) {
            throw new Error(`API调用失败: ${response.status}`);
        }

        const data = await response.json();
        return this.parseTranslationResponse(data.choices[0].message.content, keywords);

    } catch (error) {
        console.error('翻译错误:', error);
        throw error;
    }
}
```

### 3. 批量处理流程实现

#### 新增批量处理核心方法
```javascript
// 批量处理入口
async startBatchProcessing() {
    if (this.isProcessing) return;

    this.isProcessing = true;
    this.shouldStop = false;
    this.processedFiles = [];
    this.failedFiles = [];

    this.updateUIForProcessing();

    try {
        // 依次处理每个文件
        for (let i = 0; i < this.selectedFiles.length; i++) {
            if (this.shouldStop) break;

            const file = this.selectedFiles[i];
            await this.processSingleFileInBatch(file, i);
        }

        // 批量处理完成
        await this.completeBatchProcessing();

    } catch (error) {
        console.error('批量处理错误:', error);
        this.showError('批量处理过程中发生错误');
    } finally {
        this.isProcessing = false;
        this.updateUIForIdle();
    }
}

// 批量处理中的单个文件处理
async processSingleFileInBatch(file, fileIndex) {
    this.updateFileStatus(fileIndex, 'processing', '处理中...');

    try {
        // 复用现有的 processFile 方法，但修改导出逻辑
        const result = await this.processFile(file, false); // false 表示不立即下载

        this.processedFiles.push({
            file: file,
            data: result,
            index: fileIndex
        });

        this.updateFileStatus(fileIndex, 'completed', '已完成');

    } catch (error) {
        console.error(`文件处理失败: ${file.name}`, error);
        this.failedFiles.push({
            file: file,
            error: error.message,
            index: fileIndex
        });

        this.updateFileStatus(fileIndex, 'failed', '处理失败');
    }
}

// 更新文件状态显示
updateFileStatus(fileIndex, status, text) {
    const statusElement = document.getElementById(`file-${fileIndex}-status`);
    if (statusElement) {
        statusElement.className = `file-status status-${status}`;
        statusElement.textContent = text;
    }
}

// 批量处理完成
async completeBatchProcessing() {
    const successCount = this.processedFiles.length;
    const failCount = this.failedFiles.length;

    // 生成批量下载
    if (successCount > 0) {
        await this.createBatchDownload();
    }

    // 显示处理结果
    this.showBatchResult(successCount, failCount);
}
```

### 4. 批量下载实现

#### 新增批量下载方法
```javascript
// 创建批量下载
async createBatchDownload() {
    const zip = new JSZip();

    // 添加每个处理后的文件到ZIP
    for (const processedFile of this.processedFiles) {
        const workbook = this.createExcelWorkbook(processedFile.data);
        const excelBuffer = await workbook.xlsx.writeBuffer();
        zip.file(processedFile.file.name, excelBuffer);
    }

    // 生成ZIP文件并下载
    const zipBuffer = await zip.generateAsync({ type: 'arraybuffer' });
    this.downloadZipFile(zipBuffer);
}

// 下载ZIP文件
downloadZipFile(buffer) {
    const blob = new Blob([buffer], { type: 'application/zip' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `关键词处理结果_${new Date().toISOString().split('T')[0]}.zip`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// 显示批量处理结果
showBatchResult(successCount, failCount) {
    const resultDiv = document.createElement('div');
    resultDiv.className = 'batch-result';
    resultDiv.innerHTML = `
        <h3>批量处理完成</h3>
        <p>成功处理: ${successCount} 个文件</p>
        <p>处理失败: ${failCount} 个文件</p>
        ${failCount > 0 ? `<p class="error-details">失败文件: ${this.failedFiles.map(f => f.file.name).join(', ')}</p>` : ''}
    `;

    const existingResult = document.querySelector('.batch-result');
    if (existingResult) {
        existingResult.remove();
    }

    document.querySelector('.container').appendChild(resultDiv);
}
```

### 5. 错误处理实现

#### 最小化错误处理集成
```javascript
// 修改 processFile 方法添加错误处理
async processFile(file, autoDownload = true) {
    try {
        // 读取Excel文件
        const data = await this.readExcelFile(file);

        // 翻译关键词
        const translatedData = await this.translateKeywords(data);

        // 计算Kdroi和生成链接
        const processedData = translatedData.map(item => ({
            ...item,
            'Kdroi': this.calculateKdroi(item),
            'SERP': this.generateGoogleSearchLink(item.Keyword),
            'Google Trends': this.generateGoogleTrendsLink(item.Keyword),
            'Ahrefs Keyword Difficulty Checker': this.generateAhrefsLink(item.Keyword)
        }));

        // 导出文件
        if (autoDownload) {
            await this.exportToExcel(processedData, file.name);
        }

        return processedData;

    } catch (error) {
        console.error('文件处理失败:', error);
        throw new Error(`处理文件 ${file.name} 时发生错误: ${error.message}`);
    }
}

// 添加文件大小格式化方法
formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}
```

### 6. UI状态管理

#### 处理状态更新
```javascript
// 更新UI显示处理状态
updateUIForProcessing() {
    const batchProcessBtn = document.getElementById('batchProcessBtn');
    const stopBtn = document.getElementById('stopBtn');

    batchProcessBtn.disabled = true;
    batchProcessBtn.textContent = '处理中...';
    stopBtn.disabled = false;

    // 显示总体进度
    this.showBatchProgress();
}

// 更新UI显示空闲状态
updateUIForIdle() {
    const batchProcessBtn = document.getElementById('batchProcessBtn');
    const stopBtn = document.getElementById('stopBtn');

    batchProcessBtn.disabled = false;
    this.updateBatchProcessButton();
    stopBtn.disabled = true;
}

// 显示批量处理进度
showBatchProgress() {
    const progressContainer = document.createElement('div');
    progressContainer.className = 'batch-progress';
    progressContainer.innerHTML = `
        <h4>批量处理进度</h4>
        <div class="progress-bar">
            <div class="progress-fill" id="batchProgressFill"></div>
        </div>
        <div class="progress-text" id="batchProgressText">0/${this.selectedFiles.length}</div>
    `;

    document.querySelector('.container').appendChild(progressContainer);
}

// 更新批量处理进度
updateBatchProgress() {
    const completed = this.processedFiles.length + this.failedFiles.length;
    const total = this.selectedFiles.length;
    const percentage = (completed / total) * 100;

    const progressFill = document.getElementById('batchProgressFill');
    const progressText = document.getElementById('batchProgressText');

    if (progressFill) {
        progressFill.style.width = `${percentage}%`;
    }

    if (progressText) {
        progressText.textContent = `${completed}/${total}`;
    }
}
```

## 依赖库添加

### 需要添加的库
```html
<!-- 在 popup.html 中添加 JSZip 库用于批量下载 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
```

## 实施步骤

### 第一阶段：多文件选择
1. 修改 popup.html 添加多文件选择支持
2. 添加文件列表显示UI
3. 实现文件选择和列表更新逻辑
4. 添加批量处理按钮

### 第二阶段：API优化
1. 修改 translateKeywords 方法批处理大小
2. 优化批处理翻译逻辑
3. 更新进度显示机制
4. 测试大文件处理性能

### 第三阶段：批量处理
1. 实现文件队列处理逻辑
2. 添加文件状态跟踪
3. 实现批量下载功能
4. 完善进度显示

### 第四阶段：错误处理
1. 添加文件级别错误处理
2. 实现失败文件记录
3. 添加处理结果显示
4. 优化用户体验

## 测试方案

### 功能测试
- 多文件选择功能测试
- 批量处理流程测试
- 错误处理测试
- 下载功能测试

### 性能测试
- 大文件处理时间测试
- 内存使用情况测试
- API响应时间测试
- 用户体验测试

### 兼容性测试
- 不同Chrome版本测试
- 不同文件大小测试
- 不同网络环境测试
- 边界情况测试

## 风险控制

### 技术风险
- API限制：准备降级方案（500个一批）
- 内存问题：优化数据处理逻辑
- 文件格式：增强格式验证

### 用户体验风险
- 处理时间：提供明确进度显示
- 错误处理：友好的错误提示
- 文件管理：清晰的文件状态显示

## 部署方案

### 开发环境
1. 在本地Chrome扩展中测试
2. 使用开发者工具调试
3. 逐步验证功能

### 生产环境
1. 打包扩展文件
2. 更新版本号
3. 发布新版本